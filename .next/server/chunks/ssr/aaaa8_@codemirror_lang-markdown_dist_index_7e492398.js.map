{"version":3,"sources":["turbopack:///[project]/node_modules/.pnpm/@codemirror+lang-markdown@6.3.4/node_modules/@codemirror/lang-markdown/dist/index.js","turbopack:///[project]/node_modules/.pnpm/@lezer+markdown@1.4.3/node_modules/@lezer/markdown/dist/index.js"],"sourcesContent":["import { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';\nimport { CompletionContext } from '@codemirror/autocomplete';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new NodeProp();\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null || isList(type) ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction isList(type) {\n    return type.name == \"OrderedList\" || type.name == \"BulletList\";\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/foldNodeProp.add({\n                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [], context = [];\n    for (let cur = node; cur; cur = cur.parent) {\n        if (cur.name == \"FencedCode\")\n            return context;\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\nfunction normalizeIndent(content, state) {\n    let blank = /^[ \\t]*/.exec(content)[0].length;\n    if (!blank || state.facet(indentUnit) != \"\\t\")\n        return content;\n    let col = countColumn(content, 4, blank);\n    let space = \"\";\n    for (let i = col; i > 0;) {\n        if (i >= 4) {\n            space += \"\\t\";\n            i -= 4;\n        }\n        else {\n            space += \" \";\n            i--;\n        }\n    }\n    return space + content.slice(blank);\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, -1) && !markdownLanguage.isActiveAt(state, range.from, 1))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            let first = inner.node.firstChild, second = inner.node.getChild(\"ListItem\", \"ListItem\");\n            // Not second item or blank line before: delete a level of markup\n            if (first.to >= pos || second && second.to < pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move second item down, making tight two-item list non-tight\n                let insert = blankLine(context, state, line);\n                return { range: EditorSelection.cursor(pos + insert.length + 1),\n                    changes: { from: line.from, insert: insert + state.lineBreak } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = normalizeIndent(insert, state);\n        if (nonTightList(inner.node, state.doc))\n            insert = blankLine(context, state, line) + state.lineBreak + insert;\n        changes.push({ from, to: pos, insert: state.lineBreak + insert });\n        return { range: EditorSelection.cursor(from + insert.length + 1), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction nonTightList(node, doc) {\n    if (node.name != \"OrderedList\" && node.name != \"BulletList\")\n        return false;\n    let first = node.firstChild, second = node.getChild(\"ListItem\", \"ListItem\");\n    if (!second)\n        return false;\n    let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);\n    let empty = /^[\\s>]*$/.test(line1.text);\n    return line1.number + (empty ? 0 : 1) < line2.number;\n}\nfunction blankLine(context, state, line) {\n    let insert = \"\";\n    for (let i = 0, e = context.length - 2; i <= e; i++) {\n        insert += context[i].blank(i < e\n            ? countColumn(line.text, 4, context[i + 1].from) - insert.length\n            : null, i < e);\n    }\n    return normalizeIndent(insert, state);\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\n                        let insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));\n                        if (start == line.from)\n                            insert = normalizeIndent(insert, state);\n                        return { range: EditorSelection.cursor(start + insert.length),\n                            changes: { from: start, to: line.from + inner.to, insert } };\n                    }\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true, htmlTagLanguage = htmlNoMatch } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlTagLanguage.support, headerIndent], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlTagLanguage.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    let lang = mkLang(parser.configure(extensions));\n    if (completeHTMLTags)\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\n    return new LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n    if (!m)\n        return null;\n    let tree = syntaxTree(state).resolveInner(pos, -1);\n    while (tree && !tree.type.isTop) {\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\n            return null;\n        tree = tree.parent;\n    }\n    return {\n        from: pos - m[0].length, to: pos,\n        options: htmlTagCompletions(),\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nlet _tagCompletions = null;\nfunction htmlTagCompletions() {\n    if (_tagCompletions)\n        return _tagCompletions;\n    let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));\n    return _tagCompletions = result ? result.options : [];\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n","import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"Autolink\"] = 33] = \"Autolink\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n    Type[Type[\"URL\"] = 44] = \"URL\";\n})(Type || (Type = {}));\n/**\nData structure used to accumulate a block's content during [leaf\nblock parsing](#BlockParser.leaf).\n*/\nclass LeafBlock {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start position of the block.\n    */\n    start, \n    /**\n    The block's text content.\n    */\n    content) {\n        this.start = start;\n        this.content = content;\n        /**\n        @internal\n        */\n        this.marks = [];\n        /**\n        The block parsers active for this block.\n        */\n        this.parsers = [];\n    }\n}\n/**\nData structure used during block-level per-line parsing.\n*/\nclass Line {\n    constructor() {\n        /**\n        The line's full text.\n        */\n        this.text = \"\";\n        /**\n        The base indent provided by the composite contexts (that have\n        been handled so far).\n        */\n        this.baseIndent = 0;\n        /**\n        The string position corresponding to the base indent.\n        */\n        this.basePos = 0;\n        /**\n        The number of contexts handled @internal\n        */\n        this.depth = 0;\n        /**\n        Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        */\n        this.markers = [];\n        /**\n        The position of the next non-whitespace character beyond any\n        list, blockquote, or other composite block markers.\n        */\n        this.pos = 0;\n        /**\n        The column of the next non-whitespace character.\n        */\n        this.indent = 0;\n        /**\n        The character code of the character after `pos`.\n        */\n        this.next = -1;\n    }\n    /**\n    @internal\n    */\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /**\n    @internal\n    */\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /**\n    Skip whitespace after the given position, return the position of\n    the next non-space character or the end of the line if there's\n    only space after `from`.\n    */\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /**\n    @internal\n    */\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /**\n    Move the line's base position forward to the given position.\n    This should only be called by composite [block\n    parsers](#BlockParser.parse) or [markup skipping\n    functions](#NodeSpec.composite).\n    */\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /**\n    Move the line's base position forward to the given _column_.\n    */\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /**\n    Store a composite-block-level marker. Should be called from\n    [markup skipping functions](#NodeSpec.composite) when they\n    consume any non-whitespace characters.\n    */\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /**\n    Find the column position at `to`, optionally starting at a given\n    position and column.\n    */\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /**\n    Find the position corresponding to the given column.\n    */\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /**\n    @internal\n    */\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length &&\n        cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* RefStage.Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* RefStage.Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* RefStage.Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* RefStage.Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* RefStage.Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* RefStage.Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* RefStage.Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* RefStage.Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/**\nBlock-level parsing functions get access to this context object.\n*/\nclass BlockContext {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser configuration used.\n    */\n    parser, \n    /**\n    @internal\n    */\n    input, fragments, \n    /**\n    @internal\n    */\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /**\n        For reused nodes on gaps, we can't directly put the original\n        node into the tree, since that may be bigger than its parent.\n        When this happens, we create a dummy tree that is replaced by\n        the proper node in `injectGaps` @internal\n        */\n        this.reusePlaceholders = new Map;\n        this.stoppedAt = null;\n        /**\n        The range index that absoluteLineStart points into @internal\n        */\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            for (let markI = 0;;) {\n                let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;\n                while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {\n                    let mark = line.markers[markI++];\n                    this.addNode(mark.type, mark.from, mark.to);\n                }\n                if (!next)\n                    break;\n                this.finishContext();\n            }\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        this.absoluteLineStart += taken;\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /**\n    The number of parent blocks surrounding the current block.\n    */\n    get depth() {\n        return this.stack.length;\n    }\n    /**\n    Get the type of the parent block at the given depth. When no\n    depth is passed, return the type of the innermost parent.\n    */\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /**\n    Move to the next input line. This should only be called by\n    (non-composite) [block parsers](#BlockParser.parse) that consume\n    the line directly, or leaf block parser\n    [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    consume the current line (and return true).\n    */\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    /**\n    Retrieve the text of the line after the current one, without\n    actually moving the context's current line forward.\n    */\n    peekLine() {\n        return this.scanLine(this.absoluteLineEnd + 1).text;\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /**\n    @internal\n    Collect the text for the next line.\n    */\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /**\n    @internal\n    Populate this.line with the content of the next line. Skip\n    leading characters covered by composite blocks.\n    */\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /**\n    The end position of the previous line.\n    */\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /**\n    @internal\n    */\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /**\n    Start a composite block. Should only be called from [block\n    parser functions](#BlockParser.parse) that return null.\n    */\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /**\n    @internal\n    */\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /**\n    Add a block element. Can be called by [block\n    parsers](#BlockParser.parse).\n    */\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /**\n    Add a block element from a [leaf parser](#LeafBlockParser). This\n    makes sure any extra composite block markup (such as blockquote\n    markers) inside the block are also added to the syntax tree.\n    */\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /**\n    @internal\n    */\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ?\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /**\n    @internal\n    */\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /**\n    @internal\n    */\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\n        if (reuse) {\n            node = reuse;\n        }\n        else if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/**\nA Markdown parser configuration.\n*/\nclass MarkdownParser extends Parser {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser's syntax [node\n    types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    */\n    nodeSet, \n    /**\n    @internal\n    */\n    blockParsers, \n    /**\n    @internal\n    */\n    leafBlockParsers, \n    /**\n    @internal\n    */\n    blockNames, \n    /**\n    @internal\n    */\n    endLeafBlock, \n    /**\n    @internal\n    */\n    skipContextMarkup, \n    /**\n    @internal\n    */\n    inlineParsers, \n    /**\n    @internal\n    */\n    inlineNames, \n    /**\n    @internal\n    */\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /**\n        @internal\n        */\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Reconfigure the parser.\n    */\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /**\n    @internal\n    */\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /**\n    Parse the given piece of inline text at the given offset,\n    returning an array of [`Element`](#Element) objects representing\n    the inline content.\n    */\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n        top: name == \"Document\"\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/**\nElements are used to compose syntax nodes during parsing.\n*/\nclass Element {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The node's\n    [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    */\n    type, \n    /**\n    The start of the node, as an offset from the start of the document.\n    */\n    from, \n    /**\n    The end of the node.\n    */\n    to, \n    /**\n    The node's child nodes @internal\n    */\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /**\n    @internal\n    */\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /**\n    @internal\n    */\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{S}|\\\\p{P}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url) {\n            return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [\n                elt(Type.LinkMark, start, start + 1),\n                // url[0] includes the closing bracket, so exclude it from this slice\n                elt(Type.URL, start + 1, start + url[0].length),\n                elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)\n            ]));\n        }\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (canClose ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0 /* Mark.None */;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            // The destination and title must be separated by whitespace\n            if (pos != dest.to) {\n                title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n                if (title)\n                    pos = cx.skipSpace(title.to);\n            }\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/**\nInline parsing functions get access to this context, and use it to\nread the content and emit syntax nodes.\n*/\nclass InlineContext {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser that is being used.\n    */\n    parser, \n    /**\n    The text of this inline section.\n    */\n    text, \n    /**\n    The starting offset of the section in the document.\n    */\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /**\n        @internal\n        */\n        this.parts = [];\n    }\n    /**\n    Get the character code at the given (document-relative)\n    position.\n    */\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /**\n    The position of the end of this inline section.\n    */\n    get end() { return this.offset + this.text.length; }\n    /**\n    Get a substring of this inline section. Again uses\n    document-relative positions.\n    */\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /**\n    @internal\n    */\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /**\n    Add a [delimiter](#DelimiterType) at this given position. `open`\n    and `close` indicate whether this delimiter is opening, closing,\n    or both. Returns the end of the delimiter, for convenient\n    returning from [parse functions](#InlineParser.parse).\n    */\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (close ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    }\n    /**\n    Returns true when there is an unmatched link or image opening\n    token before the current position.\n    */\n    get hasOpenLink() {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))\n                return true;\n        }\n        return false;\n    }\n    /**\n    Add an inline element. Returns the end of the element.\n    */\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /**\n    Resolve markers between this.parts.length and from, wrapping matched markers in the\n    appropriate node and updating the content of this.parts. @internal\n    */\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /**\n    Find an opening delimiter of the given type. Returns `null` if\n    no delimiter is found, or an index that can be passed to\n    [`takeContent`](#InlineContext.takeContent) otherwise.\n    */\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /**\n    Remove all inline elements and delimiters starting from the\n    given index (which you should get from\n    [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    resolve delimiters inside of them, and return them as an array\n    of elements.\n    */\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /**\n    Skip space after the given (document) position, returning either\n    the position of the next non-space character or the end of the\n    section.\n    */\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            let pos = toRelative(cur.from - off, cx.ranges);\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\n                cx.addNode(cur.tree, pos);\n            }\n            else {\n                let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n                cx.reusePlaceholders.set(dummy, cur.tree);\n                cx.addNode(dummy, pos);\n            }\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n// Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n    let pos = abs;\n    for (let i = 1; i < ranges.length; i++) {\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\n        if (gapFrom < abs)\n            pos -= gapTo - gapFrom;\n    }\n    return pos;\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    \"URL Autolink\": tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/**\nThe default CommonMark parser.\n*/\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/**\nCreate a Markdown extension to enable nested parsing on code\nblocks and/or embedded HTML.\n*/\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag || id == Type.CommentBlock)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/**\nAn extension that implements\n[GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\nStrikethrough syntax using `~~` delimiters.\n*/\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\n// Parse a line as a table row and return the row count. When `elts`\n// is given, push syntax elements for the content onto it.\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/**\nThis extension provides\n[GFM-style](https://github.github.com/gfm/#tables-extension-)\ntables, using syntax like this:\n\n```\n| head 1 | head 2 |\n| ---    | ---    |\n| cell 1 | cell 2 |\n```\n*/\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.peekLine();\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/**\nExtension providing\n[GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\ntask list items, where list items can be prefixed with `[ ]` or\n`[x]` to add a checkbox.\n*/\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\nconst autolinkRE = /(www\\.)|(https?:\\/\\/)|([\\w.+-]{1,100}@)|(mailto:|xmpp:)/gy;\nconst urlRE = /[\\w-]+(\\.[\\w-]+)+(\\/[^\\s<]*)?/gy;\nconst lastTwoDomainWords = /[\\w-]+\\.[\\w-]+($|\\/)/;\nconst emailRE = /[\\w.+-]+@[\\w-]+(\\.[\\w.-]+)+/gy;\nconst xmppResourceRE = /\\/[a-zA-Z\\d@.]+/gy;\nfunction count(str, from, to, ch) {\n    let result = 0;\n    for (let i = from; i < to; i++)\n        if (str[i] == ch)\n            result++;\n    return result;\n}\nfunction autolinkURLEnd(text, from) {\n    urlRE.lastIndex = from;\n    let m = urlRE.exec(text);\n    if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf(\"_\") > -1)\n        return -1;\n    let end = from + m[0].length;\n    for (;;) {\n        let last = text[end - 1], m;\n        if (/[?!.,:*_~]/.test(last) ||\n            last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\"))\n            end--;\n        else if (last == \";\" && (m = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end))))\n            end = from + m.index;\n        else\n            break;\n    }\n    return end;\n}\nfunction autolinkEmailEnd(text, from) {\n    emailRE.lastIndex = from;\n    let m = emailRE.exec(text);\n    if (!m)\n        return -1;\n    let last = m[0][m[0].length - 1];\n    return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\n}\n/**\nExtension that implements autolinking for\n`www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\naddresses.\n*/\nconst Autolink = {\n    parseInline: [{\n            name: \"Autolink\",\n            parse(cx, next, absPos) {\n                let pos = absPos - cx.offset;\n                if (pos && /\\w/.test(cx.text[pos - 1]))\n                    return -1;\n                autolinkRE.lastIndex = pos;\n                let m = autolinkRE.exec(cx.text), end = -1;\n                if (!m)\n                    return -1;\n                if (m[1] || m[2]) { // www., http://\n                    end = autolinkURLEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && cx.hasOpenLink) {\n                        let noBracket = /([^\\[\\]]|\\[[^\\]]*\\])*/.exec(cx.text.slice(pos, end));\n                        end = pos + noBracket[0].length;\n                    }\n                }\n                else if (m[3]) { // email address\n                    end = autolinkEmailEnd(cx.text, pos);\n                }\n                else { // mailto:/xmpp:\n                    end = autolinkEmailEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && m[0] == \"xmpp:\") {\n                        xmppResourceRE.lastIndex = end;\n                        m = xmppResourceRE.exec(cx.text);\n                        if (m)\n                            end = m.index + m[0].length;\n                    }\n                }\n                if (end < 0)\n                    return -1;\n                cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\n                return end + cx.offset;\n            }\n        }]\n};\n/**\nExtension bundle containing [`Table`](#Table),\n[`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\n[`Autolink`](#Autolink).\n*/\nconst GFM = [Table, TaskList, Strikethrough, Autolink];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/**\nExtension providing\n[Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\nsuperscript using `^` markers.\n*/\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/**\nExtension providing\n[Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\nsubscript using `~` markers.\n*/\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/**\nExtension that parses two colons with only letters, underscores,\nand numbers between them as `Emoji` nodes.\n*/\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n"],"names":[],"mappings":"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","ignoreList":[0,1]}